---
title: "Snapshot Matching (R Verison)"
output: 
  html_document:
    toc: true
    code_folding: show
    toc_float: true
    theme: lumen
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = TRUE,
                      fig.height = 5,
                      fig.width = 10)

library(knitr)

```
<br><br>

# 0. Install Package 'SnapMatch'
You need to install package [optmatch](https://CRAN.R-project.org/package=optmatch), [rcbalance](https://CRAN.R-project.org/package=rcbalance) before installing the  [SnapMatch] package. It is recommanded to install package [lpSolve](https://CRAN.R-project.org/package=lpSolve) and [RItools](https://CRAN.R-project.org/package=RItools) as well. 
```{r eval=FALSE}
install.packages('optmatch')
install.packages('rcbalance')
install.packages('lpSolve')
install.packages('RItools')
library('optmatch')
library('rcbalance')
library('lpSolve')
library('RItools')
library('SnapMatch')
```
```{r echo=FALSE, message=FALSE}
library('optmatch')
library('rcbalance')
library('lpSolve')
library('RItools')
library('SnapMatch')
```

<br><br>

# 1. Optimal Snapshot Matching

Put some introduction here. 

<br>

# 2. Example
### 2.1 Load Demo Data
The demo dataset contains 20 subjects in the treatment group and 100 subject in the control group. Each subject in the control group has 5 time points. 
```{r}
dat <- SnapMatch:::demo()
head(dat)
tail(dat)
```
<br>

### 2.1 Match With Covariate Distance
We can match by mahalanobis/euclidean/rank_mahalanobis distance. 
```{r fig1, out.width = '80%'}
  # calculate the distance matrix
dis <- match_on(trt~X1+X2, data = dat, method="mahalanobis")
  # conduct optimal matching. 'Id' is the id column for each subject
pm <- optimatch_snap(dis, data = dat, id = 'id')
  # plot result
plot(xBalance(trt ~ X1+X2+strata(pm), data=dat), xlim=c(-2,1), ylim=c(0,3))
```

We find that covariate balance is achieved after snapshot matching. 

<br>

### 2.2 Match With Propensity Score
```{r fig2, out.width = '60%'}
  # calculate propensity score
prop <- glm(trt ~ X1+X2, data = dat, family = binomial())
boxplot(prop)
```

The groups do overlap, if not greatly. It may be wise to restrict the sample to the region of overlap, at least roughly. 

```{r fig3, out.width = '80%'}
  # conduct optimal matching by propensity score. 'Id' is the id column for each subject
pm <- optimatch_snap(prop, data = dat, id = 'id')
  # plot result
plot(xBalance(trt ~ X1+X2+strata(pm), data=dat), xlim=c(-2,1), ylim=c(0,3))
```

We find that similar covariate balance is achieved after snapshot matching. 

<br>

### 2.3 Complex Match With 'match_on' Function
The package accepts 'match_on' function from 'optmatch' package as a distance matrix. For example, here we show how to perform a snapshot matching within a propensity score caliper.
```{r fig4, out.width = '80%'}
  # calculate distance by propensity score
dis <- match_on(glm(trt ~ X1+X2, data = dat, family = binomial()))
dis[1:5,1:5]
  # add caliper
dis <- caliper(dis,2) + dis
dis[1:5,1:5]
  # conduct optimal snapshot matching
dis <- as.matrix(dis)
dis[which(is.infinite(dis))] <- 100
pm <- optimatch_snap(dis, data = dat, id = 'id')
  # plot result
plot(xBalance(trt ~ X1+X2+strata(pm), data=dat), xlim=c(-2,1), ylim=c(0,3))
```

